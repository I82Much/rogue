package title

import (
	termbox "github.com/nsf/termbox-go"
	"github.com/I82Much/rogue/event"
	"github.com/I82Much/rogue/render"
)

const (
	
	// generated by 	http://www.network-science.de/ascii/
	title = `

___________                         __________                             
\__    ___/__.__.______   __________\______   \ ____   ____  __ __   ____  
  |    | <   |  |\____ \_/ __ \_  __ \       _//  _ \ / ___\|  |  \_/ __ \ 
  |    |  \___  ||  |_> >  ___/|  | \/    |   (  <_> ) /_/  >  |  /\  ___/ 
  |____|  / ____||   __/ \___  >__|  |____|_  /\____/\___  /|____/  \___  >
          \/     |__|        \/             \/      /_____/             \/ 
		  
		  Press 's' to start or 'q' to quit
`

	Quit = "QUIT"
	Start = "START_GAME"
)

type Screen struct {
	listeners []event.Listener
	running bool
}

func NewModule() *Screen {
	return &Screen{}
}

func (s *Screen) AddListener(d event.Listener) {
	s.listeners = append(s.listeners, d)
}

// TODO(ndunn): render high score etc

func Render() {
	termbox.Clear(termbox.ColorDefault, termbox.ColorDefault)
	render.Render(title, 0, 0)
	termbox.Flush()
}

func (s *Screen) Start() {
	s.running = true
	Render()
	s.input()
}

func (s *Screen) Stop() {
	s.running = false
}

func (s *Screen) publishStart() {
	for _, d := range s.listeners {
		d.Listen(Start)
	}
}

func (s *Screen) publishQuit() {
	for _, d := range s.listeners {
		d.Listen(Quit)
	}
}

func (s *Screen) input() {
	for s.running {
		event := termbox.PollEvent()
		if event.Key == termbox.KeyCtrlC {
			s.publishQuit()
			s.Stop()
		}
		switch event.Ch {
		case 'S', 's':
			s.publishStart()
		case 'Q', 'q':
			s.publishQuit()
			s.Stop()
		}
	}
}


